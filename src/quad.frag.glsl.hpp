static const char *g_shader_fragment_quad = ""
#if defined(USE_LD)
"quad.frag.glsl"
#else
"#version 430\n"
"layout(location=0)uniform sampler2D surface_texture;"
"layout(location=1)uniform sampler3D noise_volume;"
"layout(location=2)uniform vec3[10] uniform_array;"
"mat3 noise_matrix=mat3(.42,-.7,.58,.53,.71,.46,-.74,.12,.67);"
"out vec4 output_color;"
"vec4 march_params=vec4(.3,.0,.7,.009);"
"vec3 light_direction=normalize(vec3(2.,.5,-1.));"
"float destruction=uniform_array[9].g;"
"bool world_toggle=1.<abs(uniform_array[7].b);"
"float sdf(vec3 point)"
"{"
"float aa,bb,cc,dd;"
"vec3 hh,ii,jj,kk;"
"if(world_toggle)"
"{"
"hh=point*.02;"
"vec4 rr=vec4(hh,1.);"
"for(int iter=0;"
"iter<9;"
"++iter)"
"{"
"rr.rgb=clamp(rr.rgb,-1.,1.)*2.-rr.rgb;"
"cc=dot(rr.rgb,rr.rgb);"
"rr*=clamp(max(.824/cc,.824),.0,1.);"
"rr=rr*vec4(vec3(-2.742),2.742)+vec4(hh,1.);"
"}"
"rr.rgb*=clamp(hh.g+1.,.1,1.);"
"cc=((length(rr.rgb)-3.259)/rr.a-.001475)*50.;"
"}"
"else"
"{"
"hh=noise_matrix*point*.007;"
"ii=noise_matrix*hh*2.61;"
"jj=noise_matrix*ii*2.11;"
"kk=noise_matrix*jj*2.11;"
"aa=texture(surface_texture,hh.rb).r*2.61;"
"bb=texture(surface_texture,ii.rb).r*1.77;"
"cc=texture(surface_texture,jj.rb).r*.11;"
"dd=texture(surface_texture,kk.rb).r*.11;"
"aa=dd+cc+pow(aa,2.)+pow(bb,2.);"
"cc=length(point.rb)*.3;"
"cc=aa*(smoothstep(.0,.5,cc*.0025)+.5)+point.g-6.*((sin(clamp(pow(cc/10.,1.8)-3.14/2.,-1.57,1.57))-1.)*2.+5.)*cos(clamp(.04*cc,.0,3.14));"
"}"
"aa=length(point-uniform_array[8].rgb);"
"if(aa<destruction)return cc+destruction-aa;"
"return cc;"
"}"
"float raycast(vec3 point,vec3 direction,float interval,out vec3 out_point,out vec3 out_normal)"
"{"
"vec3 next,mid_point;"
"float prev_value=sdf(point),current_value,mid_value,ii=1.;"
"for(;"
"ii>.0;"
"ii-=interval)"
"{"
"next=point+direction*max(prev_value*march_params.b,.02);"
"current_value=sdf(next);"
"if(.0>current_value)"
"{"
"for(int jj=0;"
"jj<5;"
"++jj)"
"{"
"mid_point=(point+next)*.5;"
"mid_value=sdf(mid_point);"
"if(.0>mid_value)"
"{"
"next=mid_point;"
"current_value=mid_value;"
"}"
"else"
"{"
"point=mid_point;"
"prev_value=mid_value;"
"}"
"}"
"out_normal=normalize(vec3(sdf(next.rgb+march_params.rgg).r,sdf(next.rgb+march_params.grg).r,sdf(next.rgb+march_params.ggr).r)-current_value);"
"break;"
"}"
"point=next;"
"prev_value=current_value;"
"}"
"out_point=point;"
"return ii;"
"}"
"float intersect_sphere(inout vec3 point,vec3 direction,vec3 center,float radius)"
"{"
"vec3 diff=point-center;"
"float ee=dot(diff,diff)-radius*radius,aa=dot(diff,direction);"
"if(0>ee||0>aa)"
"{"
"ee=aa*aa-ee;"
"if(0<ee)"
"{"
"point+=max(-aa-sqrt(ee),.0)*direction;"
"return length(aa*direction-diff);"
"}"
"}"
"return .0;"
"}"
"vec3 sample_noise(vec3 point)"
"{"
"vec3 aa,bb,cc,hh,ii,jj;"
"hh=noise_matrix*point;"
"ii=noise_matrix*hh*3.;"
"jj=noise_matrix*ii*3.;"
"aa=(texture(noise_volume,hh).rgb-.5)*2.*.6;"
"bb=(texture(noise_volume,ii).rgb-.5)*2.*.3;"
"cc=(texture(noise_volume,jj).rgb-.5)*2.*.1;"
"return normalize(aa+bb+cc);"
"}"
"void main()"
"{"
"vec2 pixcoord=gl_FragCoord.xy/360.-vec2(1.78,1.);"
"vec3 point=mix(mix(uniform_array[0],uniform_array[1],uniform_array[7].g),mix(uniform_array[1],uniform_array[2],uniform_array[7].g),uniform_array[7].g)*3.,direction=normalize(mix(uniform_array[3],uniform_array[4],uniform_array[7].g)),up=mix(uniform_array[5],uniform_array[6],uniform_array[7].g),right=normalize(cross(direction,up)),normal,intersection;"
"up=normalize(cross(right,direction));"
"direction=normalize(direction+pixcoord.r*right+pixcoord.g*up);"
"up=vec3(0);"
"float tmp1,tmp2;"
"right=vec3(109.,14.,86.);"
"if(0<int(uniform_array[7].b)%2&&.0<intersect_sphere(point,direction,right,9.))"
"{"
"direction=normalize(direction+reflect(-direction,normalize(point-right))*.2);"
"destruction=-.2;"
"world_toggle=!world_toggle;"
"}"
"if(world_toggle)march_params=vec4(.05,.0,.98,.022);"
"tmp2=raycast(point,direction,march_params.a,intersection,normal);"
"if(.0<tmp2)"
"{"
"if(world_toggle)up=max(dot(light_direction,normal),.0)*mix(vec3(.3,.6,.9),vec3(1),smoothstep(-24.,9.,intersection.g))+pow(max(dot(direction,reflect(light_direction,normal)),.0),7.)*.11;"
"else"
"{"
"tmp1=raycast(intersection+light_direction*.5,light_direction,march_params.a*3.,up,up);"
"up=(1.-tmp1)*(max(dot(light_direction,normal),.0)*mix(vec3(.8,.6,.4),vec3(1),smoothstep(-24.,9.,intersection.g))+pow(max(dot(direction,reflect(light_direction,normal)),.0),7.)*.11);"
"}"
"right=intersection-uniform_array[8];"
"tmp1=destruction+.5-length(right);"
"if(0<tmp1)up+=vec3((dot(sample_noise(intersection*.009),normalize(right))*.1)+.1,-.05,-.05)*smoothstep(.0,.5,tmp1);"
"}"
"vec3 fog=mix(vec3(.9,.8,.8),vec3(.8,.8,.9),direction.g*111.*.02)*(dot(sample_noise(point*.006+direction*.1),direction)*smoothstep(-.2,.5,-direction.g)*.2+.8);"
"if(world_toggle)tmp2=smoothstep(.0,.4,tmp2);"
"output_color=vec4(mix(mix(fog,vec3(1),pow(max(dot(direction,light_direction),.0),7.)),up,tmp2),1.)-(int(gl_FragCoord.y*.5)%2+.1)*(max(max(smoothstep(.98,1.,uniform_array[7].g),smoothstep(-.02*uniform_array[9].r,.0,-uniform_array[7].g)*uniform_array[9].r),.1)+destruction*.02)*dot(pixcoord,pixcoord);"
"right=point;"
"tmp1=intersect_sphere(right,direction,uniform_array[8],destruction+.2);"
"if(.0<tmp1)output_color.rgb-=clamp(1.-(dot(right-point,right-point)-dot(intersection-point,intersection-point))*.003,.0,1.)*(1.-pow(tmp1/destruction,5))*(dot(sample_noise((right-uniform_array[8])*.009),direction)*.1+.9);"
"}"
#endif
"";
